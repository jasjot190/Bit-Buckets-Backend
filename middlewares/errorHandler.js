const { StatusCodes } = require("http-status-codes");

const errorHandler = (err, req, res, next) => {
    let customError = {
        statusCode: err.statusCode || StatusCodes.INTERNAL_SERVER_ERROR,
        message: err.message || "something went wrong please try again",
        ...err,
    };

    // below are the errors that are not generated by the error classes and hence donot contain statusCode and message in them ... therefore we are handling them below ourself
    if (err.code && err.code === 11000) {
        let duplicateField = Object.keys(err.keyValue)[0];
        customError.message = `${duplicateField} : ${err.keyValue[duplicateField]} already exists ... please try a different ${duplicateField}`;
        // duplicate field error can happen only when the user is trying to register with pre-existing email ... hence we would know in the frontend that the duplicate key is email
        customError.errorFields = ["email"];
        customError.errorsArr = ["Email is already taken"];
        customError.statusCode = StatusCodes.CONFLICT;
    }
    if (err.name && err.name === "ValidationError") {
        let errorFields = Object.keys(err.errors);
        let errorsArr = [];
        errorFields.forEach((errField) => {
            errorsArr.push(err.errors[errField].message);
        });

        customError.message = `Validation Error : ${errorsArr.join(", ")}`;
        customError.errorsArr = errorsArr;
        customError.errorFields = errorFields;
        customError.statusCode = StatusCodes.BAD_REQUEST;
    }
    if (err.name === "CastError") {
        customError.message = `Invalid objectId Syntax : ${err.value}`;
        customError.statusCode = StatusCodes.BAD_REQUEST;
    }

    // return res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({ err });
    return res.status(customError.statusCode).json({ ...customError });
};
module.exports = errorHandler;
